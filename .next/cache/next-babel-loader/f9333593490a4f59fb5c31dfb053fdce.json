{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"C:\\\\Users\\\\bhavi\\\\Documents\\\\Coding\\\\IMA-next\\\\components\\\\IMATable.js\";\nvar __jsx = React.createElement;\n// Table.js\nimport { useTable, useFilters, useSortBy } from \"react-table\";\nimport React, { useState, useEffect } from \"react\";\n\nvar MyTextInput = function MyTextInput(_ref) {\n  var label = _ref.label,\n      props = _objectWithoutProperties(_ref, [\"label\"]);\n\n  // useField() returns [formik.getFieldProps(), formik.getFieldMeta()]\n  // which we can spread on <input> and alse replace ErrorMessage entirely.\n  var _useField = useField(props),\n      _useField2 = _slicedToArray(_useField, 2),\n      field = _useField2[0],\n      meta = _useField2[1];\n\n  return __jsx(React.Fragment, null, __jsx(\"label\", {\n    htmlFor: props.id || props.name,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12\n    },\n    __self: this\n  }, label), __jsx(\"input\", _extends({\n    className: \"text-input\"\n  }, field, props, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13\n    },\n    __self: this\n  })), meta.touched && meta.error ? __jsx(\"div\", {\n    className: \"error\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15\n    },\n    __self: this\n  }, meta.error) : null);\n};\n\nexport default function IMATable(_ref2) {\n  var columns = _ref2.columns,\n      data = _ref2.data;\n\n  // Use the useTable Hook to send the columns and data to build the table\n  // Use the useTable Hook to send the columns and data to build the table\n  var _useState = useState(\"\"),\n      filterInput = _useState[0],\n      setFilterInput = _useState[1];\n\n  var _useTable = useTable({\n    columns: columns,\n    data: data\n  }, useFilters, useSortBy),\n      getTableProps = _useTable.getTableProps,\n      getTableBodyProps = _useTable.getTableBodyProps,\n      headerGroups = _useTable.headerGroups,\n      rows = _useTable.rows,\n      prepareRow = _useTable.prepareRow,\n      setFilter = _useTable.setFilter;\n\n  var handleFilterChange = function handleFilterChange(e) {\n    var value = e.target.value || undefined;\n    setFilter(\"name\", value); // Update the show.name filter. Now our table will filter and show only the rows which have a matching value\n\n    setFilterInput(value);\n  };\n  /* \r\n    Render the UI for your table\r\n    - react-table doesn't have UI, it's headless. We just need to put the react-table props from the Hooks, and it will do its magic automatically\r\n  */\n\n\n  return __jsx(React.Fragment, null, __jsx(\"label\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 50\n    },\n    __self: this\n  }, \"Filter by Product\"), __jsx(\"input\", {\n    className: \"text-input\",\n    value: filterInput,\n    onChange: handleFilterChange,\n    placeholder: \"Search name\",\n    type: \"text\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53\n    },\n    __self: this\n  }), __jsx(\"table\", _extends({}, getTableProps(), {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 60\n    },\n    __self: this\n  }), __jsx(\"thead\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61\n    },\n    __self: this\n  }, headerGroups.map(function (headerGroup) {\n    return __jsx(\"tr\", _extends({}, headerGroup.getHeaderGroupProps(), {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63\n      },\n      __self: this\n    }), headerGroup.headers.map(function (column) {\n      return __jsx(\"th\", _extends({}, column.getHeaderProps(), {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 65\n        },\n        __self: this\n      }), column.render(\"Header\"));\n    }));\n  })), __jsx(\"tbody\", _extends({}, getTableBodyProps(), {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70\n    },\n    __self: this\n  }), rows.map(function (row, i) {\n    prepareRow(row);\n    return __jsx(\"tr\", _extends({}, row.getRowProps(), {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 74\n      },\n      __self: this\n    }), row.cells.map(function (cell) {\n      return __jsx(\"td\", _extends({}, cell.getCellProps(), {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 76\n        },\n        __self: this\n      }), cell.render(\"Cell\"));\n    }));\n  }))));\n}","map":{"version":3,"sources":["C:/Users/bhavi/Documents/Coding/IMA-next/components/IMATable.js"],"names":["useTable","useFilters","useSortBy","React","useState","useEffect","MyTextInput","label","props","useField","field","meta","id","name","touched","error","IMATable","columns","data","filterInput","setFilterInput","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","setFilter","handleFilterChange","e","value","target","undefined","map","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","render","row","i","getRowProps","cells","cell","getCellProps"],"mappings":"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","sourcesContent":["// Table.js\r\nimport { useTable, useFilters, useSortBy } from \"react-table\";\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\n\r\nconst MyTextInput = ({ label, ...props }) => {\r\n    // useField() returns [formik.getFieldProps(), formik.getFieldMeta()]\r\n    // which we can spread on <input> and alse replace ErrorMessage entirely.\r\n    const [field, meta] = useField(props);\r\n    return (\r\n      <>\r\n        <label htmlFor={props.id || props.name}>{label}</label>\r\n        <input className=\"text-input\" {...field} {...props} />\r\n        {meta.touched && meta.error ? (\r\n          <div className=\"error\">{meta.error}</div>\r\n        ) : null}\r\n      </>\r\n    );\r\n  };\r\nexport default function IMATable({ columns, data, }) {// Use the useTable Hook to send the columns and data to build the table\r\n    // Use the useTable Hook to send the columns and data to build the table\r\n    const [filterInput, setFilterInput] = useState(\"\");\r\n    const {\r\n        getTableProps, // table props from react-table\r\n        getTableBodyProps, // table body props from react-table\r\n        headerGroups, // headerGroups if your table have groupings\r\n        rows, // rows for the table based on the data passed\r\n        prepareRow, // Prepare the row (this function need to called for each row before getting the row props)\r\n        setFilter\r\n    } = useTable({\r\n        columns,\r\n        data\r\n    },\r\n        useFilters,\r\n        useSortBy \r\n    );\r\n\r\n    const handleFilterChange = e => {\r\n        const value = e.target.value || undefined;\r\n        setFilter(\"name\", value); // Update the show.name filter. Now our table will filter and show only the rows which have a matching value\r\n        setFilterInput(value);\r\n    };\r\n\r\n    /* \r\n      Render the UI for your table\r\n      - react-table doesn't have UI, it's headless. We just need to put the react-table props from the Hooks, and it will do its magic automatically\r\n    */\r\n    return (\r\n        <> \r\n        <label>\r\n            Filter by Product\r\n        </label>\r\n        <input\r\n            className=\"text-input\"\r\n            value={filterInput}\r\n            onChange={handleFilterChange}\r\n            placeholder={\"Search name\"}\r\n            type=\"text\"\r\n        />\r\n        <table {...getTableProps()}>\r\n            <thead>\r\n                {headerGroups.map(headerGroup => (\r\n                    <tr {...headerGroup.getHeaderGroupProps()}>\r\n                        {headerGroup.headers.map(column => (\r\n                            <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\r\n                        ))}\r\n                    </tr>\r\n                ))}\r\n            </thead>\r\n            <tbody {...getTableBodyProps()}>\r\n                {rows.map((row, i) => {\r\n                    prepareRow(row);\r\n                    return (\r\n                        <tr {...row.getRowProps()}>\r\n                            {row.cells.map(cell => {\r\n                                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\r\n                            })}\r\n                        </tr>\r\n                    );\r\n                })}\r\n            </tbody>\r\n        </table>\r\n        </>\r\n    );\r\n}"]},"metadata":{},"sourceType":"module"}